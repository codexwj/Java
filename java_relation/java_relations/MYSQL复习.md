# MYSQL复习

****

MyISAM和InnoDB的读音。

### MyISAM和InnoDB的区别

- 是否支持行级锁，InnoDB是支持行级锁(row-level locking)的。MyISAM只支持表级锁（table-level locking）
- 是否支持事务和崩溃后的安全恢复。MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB快，但是不提供事务支持，InnoDB支持事务，外部键。
- 是否支持外键。MyISAM不支持，InnoDB支持。
- 是否支持MVCC。仅InnoDB支持，对应高并发事务，MVCC比单纯的加锁更加高效。MVCC只在`READ COMMITTED`和`REPEATABLE READ`两个隔离级别下工作；并且可以使用乐观锁和悲观锁来实现；

讲一下多版本控制，MVCC

InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的历史数据版本可以提供给用户读，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。

- MySQL的大多数事务型引擎实现的其实都不是简单的行级锁。
- MVCC是行级锁的一个变种。
- MVCC的实现方式有多种，常见的是乐观(optimistic)并发控制和悲观(pessimistic)并发控制。
- MVCC只能在`READ COMMITED`和`REPEATABLE READ`两个隔离级别下工作。

`undo-log`

- Undo log是InnoDB MVCC事务特性的重要组成部分，当我们对记录做了变更操作时就会产生undo记录。
- Undo记录中存储的是老版本数据，
- 乐观锁可以通过版本号或者时间戳实现。

### 字符集及校对规则

字符集是指二进制编码到某种字符符号的映射，校对规则是指某种字符集下的排序规则。

MySQL采用一种类似继承的方式制定字符集的默认值，每个数据库及每张表都有自己的默认值，他们逐层继承。

### 索引

MySQL索引使用的是数据结构是主要是`BTree`和`哈希索引`。

为什么采用哈希索引：底层实现的原理是哈希表，多为单条记录查询，查询性能快。其余大部分场景，建议选择BTree。

MySQL的BTree索引采用的是B数中的B+Tree数，对于不同的存储引擎实现方式也不一样。

MyISAM：B+Tree叶节点的`data`域存放的是数据记录的地址。当索引检索时，首先按照B+Tree搜索算法搜索索引，如果指定的`key`存在，然后读取`data`域的值为地址，读取相应的数据记录，这被称为“非聚簇索引”。

InnoDB：数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键。因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”。而其他的索引称为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的结点即可取出数据，当根据辅助索引搜索时，需要先取出主键的值，再走一遍主索引。因此，在设计表时，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，不然会造成主索引频繁分裂。**

### 查询缓存的使用

执行查询语句的时候，会先查询缓存。不过，MySQL8.0版本后移除了。

### 什么是事务

**事务是逻辑上的一组操作，要么都执行，要么都不执行**

### 事务的4大特性

ACID

- 原子性（Atomicity）：事务是最小的执行单位。原子性确保事务动作要么全部完成，要么全不起作用。
- 一致性（Consistency）：执行事务前后，数据保存一致，多个事务对同一个数据读取的数据是一样的。
- 隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库是独立的。
- 持久性（Durability）：一个事务被提交以后，对数据库的改变是持久的。

### 并发事务带来了哪些问题

多个用户对同一个数据库操场导致一些问题。

- **脏读**（Dirty read）：当一个事务对一个数据进行了修改，但是还没提交到数据库中，此时另一个事务访问了这个数据，但是这个数据是还没提交的数据，那么另一个事务读读到的是一个脏的数据。因此，之后的操作不可能正确。
- **丢失修改**(Lost to modify)：指一个事务读取了一个数据，另外一个事务也访问了改数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样导致第一个事务修改的结果被丢失，因此被称为丢失修改。
- **不可重复读（Unrepeatablead）**:指一个事务内多次读取同一个数据。在这个事务还没结束的时候，另一个事务也访问了该数据，在第一个事务前后两次读取数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。发生了一个事务读取的两次数据不一致的情况，就称为不可重复读。
- **幻读**（Phantom read）：幻读和不可重复读相似，它发生在当一个事务读取了几行数据，接着另一个并发事务插入了一下数据。在随后的查询中，第一事务就会多一些原本不存在的记录，这就是幻读。
- **不可重复读与幻读区别**：不可重复读重点是某些列的值被修改，幻读的重点是在于新增和删除。

### 事务隔离级别有哪些？MySQL的默认隔离级别是？

- **READ-UNCOMMITTED**（读取未提交）：最低的隔离级别，允许读取尚未提交的数据变更。可能**导致脏读、幻读或者不可重复读**。
- **READ-COMMITTED**（读取已提交）：允许读取并发事务已经提交的数据，可以阻止**脏读，但是幻读或不可重复读仍有可能发生**
- **REPEATABLE-READ**（可重复读）：对同一字段的多次读取结果都是一致的，除非数据是被事务本身修改的，可以阻止幻读和不可重复读，但是幻读仍然有可能发生。
- **SERIALIZABLE**（可串行化），完全服从ACID的隔离级别。

`MySQL InnoDB`存储引擎的默认支持的隔离级别是`REPEATABLE-READ`（可重复读）。

InnoDB存储引擎在**REPEATABLE-READ**事务隔离级别下使用的是`Nexk-Key Lock`锁算法，因此可以避免幻读的产生。

### 锁机制与InnoDB锁算法

- MyISAM采用表级锁（table-level locking）
- InnoDB采用行级锁（row-level locking)

**表级锁和行级锁的区别**

- **表级锁**：MySQL中锁定**粒度最大**的一种锁，特点：对当前的整张表进行加锁，实现简单，消耗资源小，加锁快，不会出现死锁。由于其锁定的粒度最大，触发锁冲突的概率大，并发度低。
- **表级锁**：MySQL中锁定**粒度最小**的一种锁，特点：只对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其粒度最小，并发度最高，但加锁开销大，难度大，加锁慢，容易发生死锁。

**InnoDB存储引擎的锁的三种算法**

- Record lock: 当个行记录下的锁。
- Gap lock：间隙锁，锁定一个范围，不包括记录本身。
- Next-key lock：record+gap 锁定一个范围，包括记录本身。

**相关的知识点**

- innodb对于行的查询使用next-key lock锁
- Next-locking keying为了解决Phantom Problem幻读问题。
- 当查询的索引含有唯一属性时，将next-key lock降级为record key。
- Gap锁设计的目的是为了阻止多个事务将记录插入到同一个范围内，但会导致幻读问题产生。
- 有两个种方式显示关闭gap锁，A.将事务隔离级别设置为RC，B.将参数innodb_locks_unsafe_for_binlog设置为1。

### 大表优化

#### 限定数据范围

- 禁止不带任何限制数据范围条件查询语句。

#### 读写分离

- 主库负责写，从库负责读。

#### 垂直分区

**根据数据库里面的数据表的相关性进行拆分**。如登录信息、用户信息。

优点：使得列数据变小，简化结构

缺点：主键冗余

#### 水平分区

保持数据表结构不变，通过某种策略把存储数据分片。这样每一片数据分散到不同的表或者库中，达到分布式的目的。

### 解释一下池化思想，数据库连接池，采用数据库连接池的原因？



数据库连接本质上是一个socket连接，数据库服务端还要维护一些缓存和用户权限之类的，因此为占用一些内存。我们就把数据库连接池看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，即昂贵有浪费资源。



### 分库分表之后，id主键如何处理？

**需要一个全局id来支持**

- UUID(Universally Unique Identifier)通用唯一识别码：不适合作为主键，因为太长，并且无序不可读，查询效率低，比较适合用于生成唯一的名字如文件名。
- 数据库自增id：两台数据库分别设置不同的步长，生成不重复的id策略来实现高可用。这种生成的方式id有序，但是需要独立部署数据库实例。成本高，还有性能瓶颈。
- 



![image-20200727151534246](C:\Users\xwj\AppData\Roaming\Typora\typora-user-images\image-20200727151534246.png)

Mysiam存储引擎中的B+Tree索引方式，value存放地址。

![image-20200727151720411](C:\Users\xwj\AppData\Roaming\Typora\typora-user-images\image-20200727151720411.png)

InnoDB中Value直接存储的是行数据

#### B+Tree结构

1. `B+Tree`的叶子结点保存了所有的`key`信息，依`key`大小顺序排列。
2. `B+Tree`叶子结点元素维护了一个单项链表
3. 所有的非叶子结点都可以看作是`key`的索引部分

由于`B+Tree`只有叶子结点保存了`key`信息，查询任何key都要从`root`走到叶子。所以`B+Tree`的查询效率更加稳定。

### MySQL中的B+Tree

在原B+Tree的基础上，增加一个指向相邻叶子结点的链表指针，就形成了带有顺序指针的B+Tree，提高区间的访问性能。

![image-20200806165756207](C:\Users\xwj\AppData\Roaming\Typora\typora-user-images\image-20200806165756207.png)