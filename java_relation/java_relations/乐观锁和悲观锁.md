## 乐观锁和悲观锁

**悲观锁**：是让共享资源只让一个线程去使用，其他线程阻塞，当资源被释放之后其他线程才能去使用。其中Java中的`synchronized`和`ReentrantLock`就是悲观锁的实现。多用于多写场景。

例子：数据库中的行锁，表锁，读锁，写锁。

**乐观锁**：去访问一个共享资源的时候不会加锁，但是当更新资源的时候会判断资源是否被其他线程修改过，常用版本号机制和CAS算法实现。乐观锁多用于多读的场景，这样可以提高吞吐量。

例子：数据库中的`write_condition`机制，`java.util.concurrent.atomic`包下面的原子变量类。

**乐观锁和悲观锁的使用场景**

乐观锁适用于写比较少的场景下（即多读的情况下）

悲观锁适用于写比较多的场景下

**乐观锁的常见两种实现方式**

- **版本号机制**：一般在数据表上加一个数据版本号`version`，表示数据被修改的次数，当数据被修改时，`verion`加一。当线程A去更新数据时，也会读取数据表的`version`，在提交更新时，会将数据version加一，当提交数据版本比数据库记录的版本大时，进行更新。
- **CAS算法**：即（`compare and swap`）(比较与交换)，是一种很著名的**无锁算法**。即在没有锁的情况下实现多线程之间变量同步的方法，也是在没有线程被阻塞的情况下实现变量同步，也叫**无阻塞同步**(Non-blocking synchronization)。
- CAS**算法**：涉及3个操作数
  - 需要读写的内存中V
  - 进行比较的值A
  - 拟写入的新值B
- 当且仅当V值等于A时，CAS通过原子的方式用B值更新V。否则不会执行任何操作(比价和替换是一个原子操作)

**乐观锁的缺点**

- **ABA问题**
  - 当一个变量V的初次读取的值为A，当准备进行赋值的时候检查也是A，那么就说明该变量的值没有被其他的线程修改过。但是在这段时间这个值可能被其他线程修改了，然后又改了回来，为CAS会误认为改变量没有被修改过。这个问题就称为CAS操作的**ABA问题**。
- **循环时间开销大**
  - 自旋CAS(就是不成功就一直循环直到成功)如果长时间不成功，会给CPU带来非常大的开销。
- **只保证一个共享变量的原子操作**
  - CAS操作只对单个共享变量有效，当操作涉及跨多个共享变量时CAS操作无效。在JDK1.5之后，提供了`AtomicReference`类来保证引用对象之间的原子性，我们可以把多个变量放在一个对象里进行CAS操作。

